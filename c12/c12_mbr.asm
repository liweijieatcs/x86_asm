	;代码清单12-1
	;文件名：c12_mbr.asm
	;文件说明：硬盘主引导扇区代码 
	;创建日期：2011-10-27 22:52

	;设置堆栈段和栈指针,都初始化CS，SS为0，栈指针0x7c00
	;即栈空间是从0x7c00--0x0000都可以访问
	mov eax,cs      
	mov ss,eax
	mov sp,0x7c00

	;计算GDT所在的逻辑段地址
	mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址
	;mov eax,0x7e00
	xor edx,edx
	mov ebx,16
	;执行除法操作，被除数在edx:eax中，除数是ebx,结果商在eax,余数在edx,都是仅低16位有效
	div ebx                            ;分解成16位逻辑地址 

	mov ds,eax                         ;令DS指向该段以进行操作，指向GDT所在的逻辑段起始地址
	mov ebx,edx                        ;段内起始偏移地址

	;创建0#描述符，它是空描述符，这是处理器的要求
	mov dword [ebx+0x00],0x00000000
	mov dword [ebx+0x04],0x00000000  

	;创建1#描述符，这是一个保护模式下的数据段描述符，对应0~4GB的线性地址空间
	mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xfffff
	mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

	;创建#2保护模式下 初始 代码段描述符
	;类型为1000:只执行
	mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
	mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 
	;|----------------------------------------------------------------------------|
	;|                |  |  |  |   |  LIMIT |  |     |  |        |                |
	;|    BASE:31-24  |G |DB|L |AVL| 19--16 |P |DPL  |S |  TYPE  |    BASE:23-16  |
	;|----------------|--|--|--|---|--------|--|-----|--|--------|----------------|
	;|    31--24      |23|22|21|20 | 19--16 |15|14-13|12|  11-8  |      7--0      |
	;|----------------|--|--|--|---|--------|--|-----|--|--------|----------------|
	;|    00000000    |0 |1 |0 |0  |  0000  |1 |  00 |1 |  1000  |    00000000    |
	;|--------------------------------------|-------------------------------------|
	;|           0040                       |              9800                   |
	
	;|--------------------------------------|-------------------------------------|
	;|       SEGMENT BASE 15-0              |          SEGMENT limit 15-0         |
	;|--------------------------------------|-------------------------------------|
	;|           7c00                       |              01ff                   |
	;|--------------------------------------|-------------------------------------|

	;创建#3以上代码段的别名描述符，这和前面的指向同一个段
	;在保护模式下，代码段不可写入，但还是要修改，就只能定义同一个段，执行他，
	;但是权限改了，类型为0010:可读可写
	mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
	mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符
	;|----------------------------------------------------------------------------|
	;|                |  |  |  |   |  LIMIT |  |     |  |        |                |
	;|    BASE:31-24  |G |DB|L |AVL| 19--16 |P |DPL  |S |  TYPE  |    BASE:23-16  |
	;|----------------|--|--|--|---|--------|--|-----|--|--------|----------------|
	;|    31--24      |23|22|21|20 | 19--16 |15|14-13|12|  11-8  |      7--0      |
	;|----------------|--|--|--|---|--------|--|-----|--|--------|----------------|
	;|    00000000    |0 |1 |0 |0  |  0000  |1 |  00 |1 |  0010  |    00000000    |
	;|--------------------------------------|-------------------------------------|
	;|           0040                       |              9200                   |
	
	;|--------------------------------------|-------------------------------------|
	;|       SEGMENT BASE 15-0              |          SEGMENT limit 15-0         |
	;|--------------------------------------|-------------------------------------|
	;|           7C00                       |              01FF                   |
	;|--------------------------------------|-------------------------------------|

	;创建#4 堆栈
	mov dword [ebx+0x20],0x7c00fffe  ;基地址为0x00007c00，段界限为ffffe
	mov dword [ebx+0x24],0x00cf9600  ;粒度为4K
	;|----------------------------------------------------------------------------|
	;|                |  |  |  |   |  LIMIT |  |     |  |        |                |
	;|    BASE:31-24  |G |DB|L |AVL| 19--16 |P |DPL  |S |  TYPE  |    BASE:23-16  |
	;|----------------|--|--|--|---|--------|--|-----|--|--------|----------------|
	;|    31--24      |23|22|21|20 | 19--16 |15|14-13|12|  11-8  |      7--0      |
	;|----------------|--|--|--|---|--------|--|-----|--|--------|----------------|
	;|    00000000    |1 |1 |0 |0  |  1111  |1 |  00 |1 |  0110  |    00000000    |
	;|--------------------------------------|-------------------------------------|
	;|           00CF                       |              9600                   |
	
	;|--------------------------------------|-------------------------------------|
	;|       SEGMENT BASE 15-0              |          SEGMENT limit 15-0         |
	;|--------------------------------------|-------------------------------------|
	;|           7C00                       |              FFFE                   |
	;|--------------------------------------|-------------------------------------|

	;初始化描述符表寄存器GDTR
	mov word [cs:pgdt+0x7c00],39      ;描述符表的界限   

	;加载GDT段描述符到GDTR寄存器
	lgdt [cs:pgdt+0x7c00]

	in al,0x92                         ;南桥芯片内的端口 
	or al,0000_0010B
	out 0x92,al                        ;打开A20

	cli                                ;中断机制尚未工作

	mov eax,cr0
	or eax,1
	mov cr0,eax                        ;设置PE位

	;以下进入保护模式... ...
	;|    描述符索引               |TI |  DPL |
	;|------------------------|---|------|
	;|       15--3            | 2 | 1--0 |
	;|------------------------|---|------|
	;|      0000 0000 0001 0  | 0 |  00  |
	;|------------------------|---|------|
	;|             0010                  |
	;调到索引为#2的段寄存器，段基地址0X7C00,正好是启动的第一条指令，就是该段代码，偏移地址用标号flush给出
	jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移
	                             
	[bits 32]                          
flush:     
	;加载段描述符的顺序有要求吗？源代码的顺序是#3, #1，#2，将其修改成#1, #2, #3

	;索引号是#1的段描述符：数据段
	mov eax,0x0008                     ;加载数据段(0..4GB)选择子
	mov es,eax
	mov fs,eax
	mov gs,eax

	;索引号是#3的段描述符：代码段别名描述符，这是#2的别名段描述符，同#2指向同样的位置，权限不同：可读可写
	mov eax,0x0018                      
	mov ds,eax

	;索引号是#4的描述符：初始化代码段描述符
	mov eax,0x0020                     ;0000 0000 0010 0 000
	mov ss,eax
	xor esp,esp                        ;ESP <- 0

	;在b800处开始显示字符串
	;dword占4个字节
	;0x072e0750 07:显示格式，e0:显示点，07：显示格式，50：显示P
	mov dword [es:0x0b8000+160*8],0x072e0750 ;字符'P'、'.'及其显示属性
	mov dword [es:0x0b8004+160*8],0x072e074d ;字符'M'、'.'及其显示属性
	mov dword [es:0x0b8008+160*8],0x07200720 ;两个空白字符及其显示属性
	mov dword [es:0x0b800c+160*8],0x076b076f ;字符'o'、'k'及其显示属性

	;开始冒泡排序
	;每次执行@@1...@@1的时候ecx都会减去1，
	;每次执行@@2...@@2的时候ecx会用到@@1中的ecx,并且减1，直到减到0，跳出@@2循环
	;
	mov ecx,pgdt-string-1              ;遍历次数=串长度-1 
@@1:
	push ecx                           ;32位模式下的loop使用ecx 
	xor bx,bx                          ;32位模式下，偏移量可以是16位，也可以 
@@2:                                       ;是后面的32位 
	mov ax,[string+bx] 
	cmp ah,al                          ;ah中存放的是源字的高字节 
	jge @@3 			   ;如果ah >= al，则直接跳转到@@3,如果ah < al则交换ah和al,则ah中存储最大值
					    
	;jle @@3
	xchg al,ah 
	mov [string+bx],ax		   ;每次都增加bx，这样执完一遍内循环则将ascii最大的值交换到最右边(bx最大)

@@3:
	inc bx 
	loop @@2

	pop ecx 
	loop @@1

	;显示排列好的字符串
	mov ecx,pgdt-string
	xor ebx,ebx				;偏移地址是32位的情况 
@@4:						;32位的偏移具有更大的灵活性
	mov ah,0x06
	mov al,[string+ebx]
	mov [es:0xb80a0+ebx*2+160*8],ax          ;演示0~4GB寻址。
	inc ebx
	loop @@4

	hlt 

;-------------------------------------------------------------------------------
	string           db 's0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.'
;-------------------------------------------------------------------------------
	pgdt             dw 0		    ;留给GDT的大小使用
                         dd 0x00007e00      ;GDT的物理地址
;-------------------------------------------------------------------------------                             
	times 510-($-$$) db 0
        db 0x55,0xaa
